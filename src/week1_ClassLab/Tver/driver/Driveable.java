package week1_ClassLab.Tver.driver;

public interface Driveable {
	//이제 인터페이스도 바디를 가질 수 있다. 
	//연결된 클래스마다  일반적으로 동작하게 할  메소드라면 여기서 구현해도 된다.
	//
	//인자가 없는 drive()는 무의미 하므로 오버로딩하지 않아도 된다. 혹은 아래처럼 안내메시지가 출력되도록 처리해도 된다.
	public default void drive() {
		System.out.println("모든 Vehicle을 운전할 수 있습니다. 움직일 객체를 인자로 넣어주세요");
	}	
	
	//인자를 어떤 타입으로 넘기는 것이 좋을까?
	//public  void drive(Moveable m);	
	//public  void drive(Vehicle v);
	
	//여기서부터, 부모의 마음이 되어 생각해보는 것도 좋다. 상상하자!ㅁ
	//탱크, 비행기, 버스를 인자로 받는 drive()도 지정할 수 있으나, 인터페이스는 반드시 해야하는 should!의 개념이 있다
	//자식클래스들에게 있어서 '반드시'란 건 부담이 될 수 있으므로, 일반적이고 공통적인 것은
	//이들의 부모클래스인 Vehicle에서 구현해 두고 상속받아 쓰게 하여 자식클래스의 부담을 덜어줄 수 있다.
	//그러나,자식 클래스들들이 자신의 클래스에 맞게 override(재정의,재수정) 할 수 있다.
	
	//때론, 부모입장에서는, 어짜피 내가 물려줘도 자식은 물려받는 메소드 대신 자신의 메소드를 사용할 것을  안다면, 
	//바디가 없이 선언만 해두는 것이 가능하다.   
	//자식클래스에서 재정의하여 사용할 것이라면, 부모클래스에서는 굳이 바디가 있는 구현된(구상)메소드 대신
	//바디가 없이 프로토타입만 있는 추상메소드로 정의해도 된다.  
	//public abstract void drive(); 처럼.  abstract 키워드를 붙이고
	//abstract 메소드가 하나라도 있는 클래스는 추상메소드라고 부르며, abstract클래스로 정의하고 클래스 옆에도 키워드를 추가한다.  
	//abstract클래스는 이제부터 new로 생성할 수 없는, 참조만 가능한 타입이 되고
	//어쩌면 더 의미에 맞는 표현이다.  객체들은 최종 말단클래스의 모양으로 생성되므로..!
	//세상엔 동물,탈것이란 객체는 없다. 토기, 호랑이를 동물이라고 부르고, 자동차, 비행기를 탈컷으로 지칭할 뿐.
	
	
	//객체를 지향한다는 것은 이렇다...
	//보다 좋은 , 최적의 처리방식을 고민하는 알고리즘을 구현하는 일과는 또 다르다.
	//가장 작게는 어떤 객체가 가진 속성과 메소드를 파악하는 것에서 부터 시작하지만
	//왜 존재하는가, 그렇게 존재하여  어떤 역할을 하고 어떤 역할을 맡길 것인가로 나아간다...
	//마치 나는 누구인가? 무엇을 해야하는가? '누구'와 '무엇'을 '어떻게' 하며 살고있는가를 생각하는 것처럼
	//객체를 지향한다는 것은 이렇다...마냥 기술적인 것 같지만,  결국엔 '.'에서 부터 혹은 작은 생각에서 출발하여 더 큰 세상으로 나아간다.
	
	//그래서 어려운 가보다.  
	//세상으로 나와서, 모든 것을 내가 계획하고 내가 결정해야 했을 때 자유로움을 느꼈지만, 한편으론 어렵고 외로웠다.. 틀릴때도 많았다!
	//여러분들에겐 '교수'가 있고 생각보다 교수는 많은 기능을 가지고 있다. - 학점을 주는 기능외에도.
	//그러니 남은 두달동안 마음껏 활용하자!!!

}

